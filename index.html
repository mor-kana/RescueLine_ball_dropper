<!DOCTYPE html>
<html lang="en">
<head><!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Rescue Line Evacuation zone arrengement tool</title>
  <style>
    canvas {
      border: 1px solid #ccc;
    }
    .controls {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h3>Rescue Line Evacuation zone arrengement tool</h3>
  <canvas id="field" width="600" height="450"></canvas>
  <div class="controls">
    <label><input type="checkbox" class="corner-option" value="A" checked> A</label>
    <label><input type="checkbox" class="corner-option" value="B" checked> B</label>
    <label><input type="checkbox" class="corner-option" value="C" checked> C</label>
    <label><input type="checkbox" class="corner-option" value="D" checked> D</label>
    <br>
    <small>✓を付けた角の中からランダムに赤と緑の三角コーナーが1つずつ選ばれます。 / Corners with checkmarks are eligible for red and green triangle placement (one each randomly selected).</small>
    <br>
    <select id="mode">
      <option value="balls">ボールのみランダム配置 / Random balls only</option>
      <option value="both">ボール＋三角コーナーもランダム配置 / Random balls & triangle corners</option>
    </select>
    <button onclick="dropBalls()">Drop!</button>
  </div>

  <script>
    const canvas = document.getElementById("field");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const gridSize = 150;
    const ballRadius = 13;
    const corners = ['A', 'B', 'C', 'D'];
    let redCorner = null;
    let greenCorner = null;
    let balls = [];

    function drawGrid() {
      ctx.strokeStyle = '#eee';
      for (let x = 0; x <= width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y <= height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }

    function drawCornerLabels() {
      ctx.fillStyle = 'black';
      ctx.font = '16px sans-serif';
      ctx.fillText("A", 5, 15);
      ctx.fillText("B", width - 15, 15);
      ctx.fillText("C", width - 15, height - 5);
      ctx.fillText("D", 5, height - 5);
    }

    function drawTriangle(corner, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      if (corner === 'A') {
        ctx.moveTo(0, 0);
        ctx.lineTo(gridSize, 0);
        ctx.lineTo(0, gridSize);
      } else if (corner === 'B') {
        ctx.moveTo(width, 0);
        ctx.lineTo(width - gridSize, 0);
        ctx.lineTo(width, gridSize);
      } else if (corner === 'C') {
        ctx.moveTo(width, height);
        ctx.lineTo(width - gridSize, height);
        ctx.lineTo(width, height - gridSize);
      } else if (corner === 'D') {
        ctx.moveTo(0, height);
        ctx.lineTo(gridSize, height);
        ctx.lineTo(0, height - gridSize);
      }
      ctx.closePath();
      ctx.fill();
    }

    function drawBalls() {
      for (let b of balls) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        ctx.fill();
      }
    }

    function isInTriangle(x, y, corner) {
      let px = x, py = y;
      if (corner === 'A') return px + py <= gridSize;
      if (corner === 'B') return (width - px) + py <= gridSize;
      if (corner === 'C') return (width - px) + (height - py) <= gridSize;
      if (corner === 'D') return px + (height - py) <= gridSize;
      return false;
    }

    function placeBalls() {
      balls = [];
      const allCorners = [redCorner, greenCorner];
      const colors = ['silver', 'silver', 'black'];
      while (balls.length < colors.length) {
        const x = Math.random() * (width - 2 * ballRadius) + ballRadius;
        const y = Math.random() * (height - 2 * ballRadius) + ballRadius;
        const overlap = balls.some(b => Math.hypot(b.x - x, b.y - y) < 2 * ballRadius);
        const inTriangle = allCorners.some(c => isInTriangle(x, y, c));
        if (!overlap && !inTriangle) {
          balls.push({ x, y, color: colors[balls.length] });
        }
      }
    }

    function drawField() {
      ctx.clearRect(0, 0, width, height);
      drawGrid();
      if (redCorner) drawTriangle(redCorner, 'red');
      if (greenCorner) drawTriangle(greenCorner, 'green');
      drawCornerLabels();
      drawBalls();
    }

    function dropBalls() {
      const selectedCorners = [...document.querySelectorAll('.corner-option:checked')].map(e => e.value);
      const mode = document.getElementById("mode").value;

      if (selectedCorners.length < 2) {
        alert("2つ以上の角を選んでください / Please select at least two corners.");
        return;
      }
      if (selectedCorners.length > 4) {
        alert("角の数が多すぎます / Too many corners selected.");
        return;
      }

      if (mode === 'both') {
        let choices = [...selectedCorners];
        let first = choices.splice(Math.floor(Math.random() * choices.length), 1)[0];
        let second = choices[Math.floor(Math.random() * choices.length)];
        [redCorner, greenCorner] = Math.random() < 0.5 ? [first, second] : [second, first];
      }
      placeBalls();
      drawField();
    }

    drawField();
  </script>
</body>
</html>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rescue Line Ball Dropper</title>
<style>
  body { font-family: Arial, sans-serif; }
  #canvas { border: 2px solid black; background: white; display: block; margin: 10px auto; }
  #controls { text-align: center; margin: 10px; }
  label { margin: 0 10px; }
  #error { color: red; font-weight: bold; }
</style>
</head>
<body>

<h2 style="text-align:center;">Rescue Line Ball Dropper</h2>

<div id="controls">
  <label><input type="checkbox" id="cornerA" /> A</label>
  <label><input type="checkbox" id="cornerB" /> B</label>
  <label><input type="checkbox" id="cornerC" /> C</label>
  <label><input type="checkbox" id="cornerD" /> D</label>
  <button id="dropBtn">Drop!</button>
</div>

<div id="error"></div>
<canvas id="canvas" width="600" height="450"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const FIELD_WIDTH = 600;   // mm, half size of original 900x1200 => scaled 600x450 for 900x1200->600x450
const FIELD_HEIGHT = 450;  // mm
const GRID_SIZE = 150;     // 300/2 = 150mm grid size (half size)
const BALL_DIAMETER = 25;  // mm
const BALL_RADIUS = BALL_DIAMETER / 2;
const WALL_THICKNESS = 10;

const corners = ['A','B','C','D'];

// Triangle corners coordinates
// Right is +x, down is +y
// A=top-left, B=top-right, C=bottom-right, D=bottom-left
// Each triangle is right isosceles triangle 300x300 scaled to 150x150
const TRIANGLES = {
  A: [ {x:0, y:0}, {x:GRID_SIZE, y:0}, {x:0, y:GRID_SIZE} ],
  B: [ {x:FIELD_WIDTH, y:0}, {x:FIELD_WIDTH - GRID_SIZE, y:0}, {x:FIELD_WIDTH, y:GRID_SIZE} ],
  C: [ {x:FIELD_WIDTH, y:FIELD_HEIGHT}, {x:FIELD_WIDTH - GRID_SIZE, y:FIELD_HEIGHT}, {x:FIELD_WIDTH, y:FIELD_HEIGHT - GRID_SIZE} ],
  D: [ {x:0, y:FIELD_HEIGHT}, {x:GRID_SIZE, y:FIELD_HEIGHT}, {x:0, y:FIELD_HEIGHT - GRID_SIZE} ],
};

let activeCorners = [];

const BALL_COLORS = ['silver', 'silver', 'black']; // 2 silver balls, 1 black ball

let balls = [];

const errorDiv = document.getElementById('error');

function drawGrid(){
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  ctx.lineWidth = 1;
  for(let x=0; x<=FIELD_WIDTH; x += GRID_SIZE){
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, FIELD_HEIGHT);
    ctx.stroke();
  }
  for(let y=0; y<=FIELD_HEIGHT; y += GRID_SIZE){
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(FIELD_WIDTH, y);
    ctx.stroke();
  }
}

function drawWalls(){
  ctx.strokeStyle = 'black';
  ctx.lineWidth = WALL_THICKNESS;
  ctx.strokeRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
}

function drawTriangle(corner){
  const pts = TRIANGLES[corner];
  ctx.fillStyle = 'rgba(255,0,0,0.3)';
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  ctx.lineTo(pts[1].x, pts[1].y);
  ctx.lineTo(pts[2].x, pts[2].y);
  ctx.closePath();
  ctx.fill();

  // Draw label near corner
  ctx.fillStyle = 'red';
  ctx.font = '20px Arial';
  let labelX = pts[0].x;
  let labelY = pts[0].y;
  // Adjust label position so it's visible inside canvas
  if(corner === 'A') { labelX += 10; labelY += 25; }
  else if(corner === 'B') { labelX -= 20; labelY += 25; }
  else if(corner === 'C') { labelX -= 20; labelY -= 10; }
  else if(corner === 'D') { labelX += 10; labelY -= 10; }
  ctx.fillText(corner, labelX, labelY);
}

function pointInTriangle(px, py, tri){
  // Barycentric technique
  const [A, B, C] = tri;
  const v0 = {x:C.x - A.x, y:C.y - A.y};
  const v1 = {x:B.x - A.x, y:B.y - A.y};
  const v2 = {x:px - A.x, y:py - A.y};

  const dot00 = v0.x * v0.x + v0.y * v0.y;
  const dot01 = v0.x * v1.x + v0.y * v1.y;
  const dot02 = v0.x * v2.x + v0.y * v2.y;
  const dot11 = v1.x * v1.x + v1.y * v1.y;
  const dot12 = v1.x * v2.x + v1.y * v2.y;

  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  return (u >= 0) && (v >= 0) && (u + v <= 1);
}

// Calculate squared distance from point (px,py) to segment AB
function distPointToSegmentSquared(px, py, ax, ay, bx, by){
  const abx = bx - ax;
  const aby = by - ay;
  const apx = px - ax;
  const apy = py - ay;
  const abLenSq = abx*abx + aby*aby;
  let t = (apx*abx + apy*aby) / abLenSq;
  t = Math.max(0, Math.min(1, t));
  const closestX = ax + t*abx;
  const closestY = ay + t*aby;
  const dx = px - closestX;
  const dy = py - closestY;
  return dx*dx + dy*dy;
}

// Check if circle with center cx,cy radius r overlaps triangle pts
function circleIntersectsTriangle(cx, cy, r, tri){
  // If center inside triangle
  if(pointInTriangle(cx, cy, tri)) return true;

  // Check distance to each edge
  for(let i=0; i<3; i++){
    const a = tri[i];
    const b = tri[(i+1)%3];
    const distSq = distPointToSegmentSquared(cx, cy, a.x, a.y, b.x, b.y);
    if(distSq <= r*r) return true;
  }
  return false;
}

function isBallInAnyTriangle(x, y){
  for(let corner of activeCorners){
    if(circleIntersectsTriangle(x, y, BALL_RADIUS, TRIANGLES[corner])) return true;
  }
  return false;
}

function generateBalls(){
  balls = [];
  let attempts = 0;
  while(balls.length < BALL_COLORS.length){
    if(attempts > 1000){
      errorDiv.textContent = "Failed to place balls without collision after many attempts.";
      return false;
    }
    const x = WALL_THICKNESS + BALL_RADIUS + Math.random() * (FIELD_WIDTH - 2*(WALL_THICKNESS + BALL_RADIUS));
    const y = WALL_THICKNESS + BALL_RADIUS + Math.random() * (FIELD_HEIGHT - 2*(WALL_THICKNESS + BALL_RADIUS));

    // Check collision with triangles
    if(isBallInAnyTriangle(x, y)) {
      attempts++;
      continue;
    }

    // Check collision with existing balls
    let collides = false;
    for(let b of balls){
      const dx = b.x - x;
      const dy = b.y - y;
      const distSq = dx*dx + dy*dy;
      if(distSq < (BALL_DIAMETER*BALL_DIAMETER)){
        collides = true;
        break;
      }
    }
    if(collides){
      attempts++;
      continue;
    }

    balls.push({x, y, color: BALL_COLORS[balls.length]});
  }
  errorDiv.textContent = "";
  return true;
}

function drawBalls(){
  for(let b of balls){
    ctx.beginPath();
    ctx.fillStyle = b.color;
    ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function redraw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  drawWalls();
  for(let c of activeCorners){
    drawTriangle(c);
  }
  drawBalls();
}

function onCheckboxChange(event){
  const cb = event.target;
  const corner = cb.id.slice(-1);

  if(cb.checked){
    if(activeCorners.length >= 2){
      // More than 2 selected: remove last selected corner before this one
      const last = activeCorners[activeCorners.length-1];
      activeCorners.pop();
      document.getElementById('corner' + last).checked = false;
    }
    activeCorners.push(corner);
  } else {
    // unchecked: remove from activeCorners
    activeCorners = activeCorners.filter(c => c !== corner);
  }
  redraw();
}

function onDrop(){
  if(activeCorners.length !== 2){
    errorDiv.textContent = "Error: 選択できる避難場所は2つまでです!";
    return;
  }
  // Generate balls respecting active corners
  if(generateBalls()){
    errorDiv.textContent = "";
    redraw();
  }
}

// Initialize event listeners
for(let c of corners){
  document.getElementById('corner' + c).addEventListener('change', onCheckboxChange);
}

document.getElementById('dropBtn').addEventListener('click', onDrop);

// Initial draw
redraw();

</script>

</body>
</html>
